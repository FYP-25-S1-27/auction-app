"use client";

import {
  Box,
  CircularProgress,
  IconButton,
  Stack,
  TextField,
  Typography,
} from "@mui/material";
import SendIcon from "@mui/icons-material/Send";
import { useCallback, useEffect, useRef, useState } from "react";
import sendMessage from "@/libs/actions/db/chats/sendMessage";
import getChatMessages from "@/libs/actions/db/chats/getChatMessages";
import { InferSelectModel } from "drizzle-orm";
import { chatMessages } from "@/libs/db/schema";
import { formatRelative } from "date-fns";
import { MessageData } from "@/libs/types/socketData";
import { socket } from "@/libs/sio";

interface ConversationBodyProps {
  conversationId: string;
  otherPartyUuid: string;
  // otherPartyUsername: string;
}

export default function ConversationBody({
  conversationId,
  otherPartyUuid,
}: // otherPartyUsername,
ConversationBodyProps) {
  const [message, setMessage] = useState<string>("");
  const [sendMessageStatus, setSendMessageStatus] =
    useState<Awaited<ReturnType<typeof sendMessage>>>();

  const [conversationStatus, setConversationStatus] =
    useState<Awaited<ReturnType<typeof getChatMessages>>>();
  const [conversationHistory, setConversationHistory] = useState<
    InferSelectModel<typeof chatMessages>[] | undefined
  >();

  const chatHistoryContainerRef = useRef<HTMLDivElement>(null);

  const _getChatMessages = useCallback(() => {
    getChatMessages(otherPartyUuid).then((messages) => {
      if (messages === "Unauthorized") {
        setConversationStatus(messages);
      } else {
        setConversationHistory(messages);
      }
    });
  }, [otherPartyUuid]);

  useEffect(() => {
    const handleIncomingMessage = (messageData: MessageData) => {
      console.log("Received message:", messageData);

      // Immediately update UI with new message
      const newMessage: InferSelectModel<typeof chatMessages> = {
        id: -1, // Placeholder, as ID is usually auto-generated by the server
        message: messageData.message,
        senderUuid: otherPartyUuid,
        receiverUuid: "", // Placeholder, as receiverUuid is not provided and not needed
        conversationId: conversationId,
        createdAt: new Date().toISOString(), // Use current time for the message
      };
      setConversationHistory((prev) =>
        prev ? [...prev, newMessage] : [newMessage]
      );

      // Then sync with server
      setTimeout(() => {
        _getChatMessages();
      }, 500); // Small delay to ensure message is processed
    };

    socket.on("message", handleIncomingMessage);

    return () => {
      socket.off("message", handleIncomingMessage);
    };
  }, [_getChatMessages, conversationId, otherPartyUuid]);

  useEffect(() => {
    _getChatMessages();
  }, [_getChatMessages, conversationId, otherPartyUuid]);
  useEffect(() => {
    if (chatHistoryContainerRef.current) {
      chatHistoryContainerRef.current.scrollTop =
        chatHistoryContainerRef.current.scrollHeight;
    }
  }, [conversationHistory]); // Scroll when messages change
  function handleSendMessage() {
    sendMessage(conversationId, message, otherPartyUuid).then((status) => {
      return setSendMessageStatus(status);
    });
    // Update the conversation history after sending a message
    _getChatMessages();
    // Emit the message to the server
    const messageData: MessageData = {
      message: message,
      conversationId: otherPartyUuid,
    };
    socket.emit("message", messageData);
    // Clear the message input after sending
    setMessage("");
  }

  return (
    <Stack direction={"column"} spacing={2} sx={{ padding: 2 }}>
      {/* <Stack direction={"row"} justifyContent={"flex-start"} width={"100%"}>
        <Box bgcolor={"black"} height={10} width={10} />
      </Stack>

      <Stack direction={"row"} justifyContent={"flex-end"} width={"100%"}>
        <Box bgcolor={"black"} height={10} width={10} />
      </Stack> */}

      {/* Scrollable conversation history */}
      <Box
        ref={chatHistoryContainerRef}
        sx={{
          flex: 1, // Take remaining space
          overflowY: "auto", // Enable vertical scrolling
          minHeight: "60vh", // Minimum height to ensure it takes up some space
          maxHeight: "60vh", // Limit height to 60% of viewport height
          padding: 1,
          "&::-webkit-scrollbar": {
            width: "8px",
          },
          "&::-webkit-scrollbar-track": {
            background: "#f1f1f1",
            borderRadius: "4px",
          },
          "&::-webkit-scrollbar-thumb": {
            background: "#888",
            borderRadius: "4px",
          },
        }}
      >
        {typeof conversationStatus === "string" && (
          <Typography variant="body1">{conversationStatus}</Typography>
        )}
        {!Array.isArray(conversationHistory) ? (
          <CircularProgress />
        ) : (
          conversationHistory.map((message) => (
            <Stack
              key={message.id}
              direction={"row"}
              justifyContent={
                message.senderUuid === otherPartyUuid
                  ? "flex-start"
                  : "flex-end"
              }
              width={"100%"}
            >
              {" "}
              <Box
                sx={{
                  mt: 1,
                  position: "relative",
                  maxWidth: "70%",
                  borderColor:
                    message.senderUuid === otherPartyUuid ? "black" : "#007C5F",
                  borderRadius: 2,
                  borderWidth: 1,
                  padding: 1.5,
                  // "&::before": {
                  //   content: '""',
                  //   position: "absolute",
                  //   width: 0,
                  //   height: 0,
                  //   bottom: 0,
                  //   ...(message.senderUuid === otherPartyUuid
                  //     ? {
                  //         left: -8,
                  //         borderRight: "10px solid white",
                  //         borderBottom: "10px solid transparent",
                  //       }
                  //     : {
                  //         right: -8,
                  //         borderLeft: "10px solid #007C5F",
                  //         borderBottom: "10px solid transparent",
                  //       }),
                  // },
                }}
              >
                <Typography variant="body2">
                  {formatRelative(message.createdAt, new Date())}
                </Typography>
                <Typography variant="body1" marginY={1} maxWidth={"15em"}>
                  {message.message}
                </Typography>
              </Box>
            </Stack>
          ))
        )}
      </Box>
      <Stack direction={"column"}>
        {sendMessageStatus && (
          <Typography variant={"subtitle2"}>{sendMessageStatus}</Typography>
        )}
        <Stack direction={"row"} alignItems={"center"} gap={2}>
          <TextField
            placeholder="Write a message"
            fullWidth
            value={message}
            onChange={(e) => setMessage(e.target.value)}
            onKeyDown={(e) => {
              if (e.key === "Enter" && !e.shiftKey && message) {
                e.preventDefault();
                handleSendMessage();
              }
            }}
          />
          <IconButton
            aria-label="send message"
            onClick={handleSendMessage}
            disabled={!message}
          >
            <SendIcon />
          </IconButton>
        </Stack>
      </Stack>
    </Stack>
  );
}
